/**
 * drfrank
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Account {
    "address"?: string;
    "phone"?: string;
    "kind"?: string;
    "role"?: string;
    "status"?: string;
    "realm"?: string;
    "username"?: string;
    "email": string;
    "emailVerified"?: boolean;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface AccountAccessToken {
    "id": string;
    /**
     * time to live in seconds (2 weeks by default)
     */
    "ttl"?: number;
    /**
     * Array of scopes granted to this access token.
     */
    "scopes"?: Array<string>;
    "created"?: Date;
    "userId"?: number;
}

export interface Application {
    "id": string;
    "realm"?: string;
    "name": string;
    "description"?: string;
    /**
     * The icon image url
     */
    "icon"?: string;
    /**
     * The user id of the developer who registers the application
     */
    "owner"?: string;
    /**
     * A list of users ids who have permissions to work on this app
     */
    "collaborators"?: Array<string>;
    "email"?: string;
    "emailVerified"?: boolean;
    /**
     * The application URL for OAuth 2.0
     */
    "url"?: string;
    /**
     * OAuth 2.0 code/token callback URLs
     */
    "callbackUrls"?: Array<string>;
    /**
     * A list of permissions required by the application
     */
    "permissions"?: Array<string>;
    "clientKey"?: string;
    "javaScriptKey"?: string;
    "restApiKey"?: string;
    "windowsKey"?: string;
    "masterKey"?: string;
    "pushSettings"?: any;
    "authenticationEnabled"?: boolean;
    "anonymousAllowed"?: boolean;
    "authenticationSchemes"?: Array<any>;
    /**
     * Status of the application, production/sandbox/disabled
     */
    "status"?: string;
    "created"?: Date;
    "modified"?: Date;
}

export interface Ask {
    "fullname"?: string;
    "email"?: string;
    "description"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Company {
    "name"?: string;
    "email"?: string;
    "phone"?: string;
    "address"?: string;
    "level"?: string;
    "director"?: string;
    "status"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Course {
    "name"?: string;
    "description"?: string;
    "image"?: string;
    "url"?: string;
    "price"?: string;
    "discount"?: string;
    "kind"?: string;
    "teacher"?: string;
    "time"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Faq {
    "question"?: string;
    "answers"?: string;
    "kind"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface InlineResponse200 {
    "exists"?: boolean;
}

/**
 * Information related to the outcome of the operation
 */
export interface InlineResponse2001 {
    /**
     * The number of instances updated
     */
    "count"?: number;
}

export interface InlineResponse2002 {
    "count"?: number;
}

export interface InlineResponse2003 {
    "undefined"?: any;
}

export interface InlineResponse2004 {
    "result"?: any;
}

export interface Installation {
    "appId": string;
    "appVersion"?: string;
    "badge"?: number;
    "created"?: Date;
    "deviceToken": string;
    "deviceType": string;
    "modified"?: Date;
    "status"?: string;
    "subscriptions"?: Array<string>;
    "timeZone"?: string;
    "userId"?: string;
    "id"?: number;
}

export interface Notification {
    "alert"?: any;
    "badge"?: number;
    "category"?: string;
    "collapseKey"?: string;
    "contentAvailable"?: boolean;
    "created"?: Date;
    "delayWhileIdle"?: boolean;
    "deviceToken": string;
    "deviceType": string;
    "expirationInterval"?: number;
    "expirationTime"?: Date;
    "modified"?: Date;
    "scheduledTime"?: Date;
    "sound"?: string;
    "status"?: string;
    "urlArgs"?: Array<string>;
    "id"?: number;
}

export interface Post {
    "title"?: string;
    "image"?: string;
    "description"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Product {
    "name"?: string;
    "feature"?: string;
    "kind"?: string;
    "price"?: string;
    "discount"?: number;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Push {
    "id"?: number;
}

export interface Role {
    "id"?: number;
    "name": string;
    "description"?: string;
    "created"?: Date;
    "modified"?: Date;
}

/**
 * Map principals to roles
 */
export interface RoleMapping {
    "id"?: number;
    /**
     * The principal type, such as USER, APPLICATION, ROLE, or user model name in case of multiple user models
     */
    "principalType"?: string;
    "principalId"?: string;
    "roleId"?: number;
}

export interface Submissions {
    "groupName"?: string;
    "teacher"?: string;
    "class"?: string;
    "phone"?: number;
    "city"?: string;
    "district"?: string;
    "school"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}



/**
 * AccountApi - fetch parameter creator
 */
export const AccountApiFetchParamCreator = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): FetchArgs {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any): FetchArgs {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: { "oldPassword": string; "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: { "uid": string; "token": string; "redirect"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: { "credentials": any; "include"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogout(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: { "id": string; "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountAccessToken>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: { "id": string; "fk": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: { "id": string; "fk": string; "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: { "id": string; "fk": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: { "options": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: { "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
        return AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
        return AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any) {
        return AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFind(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
        return AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any) {
        return AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
        return AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountAccessToken; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any) {
        return AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any) {
        return AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param oldPassword 
         * @param newPassword 
         */
        accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
            return AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param uid 
         * @param token 
         * @param redirect 
         */
        accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
            return AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params: {  "where"?: string; }, options?: any) {
            return AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFind(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param credentials 
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
            return AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         */
        accountLogout(options?: any) {
            return AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
            return AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountAccessToken; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param options 
         */
        accountResetPassword(params: {  "options": any; }, options?: any) {
            return AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param newPassword 
         */
        accountSetPassword(params: {  "newPassword": string; }, options?: any) {
            return AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * AccountAccessTokenApi - fetch parameter creator
 */
export const AccountAccessTokenApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountAccessTokenCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountAccessTokenCreate(params: {  "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountAccessTokenCreateChangeStreamGetAccountAccessTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountAccessTokenCreateChangeStreamPostAccountAccessTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountAccessTokenDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenDeleteById");
        }
        const baseUrl = `/AccountAccessTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountAccessTokenExistsGetAccountAccessTokensidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenExistsGetAccountAccessTokensidExists");
        }
        const baseUrl = `/AccountAccessTokens/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountAccessTokenExistsHeadAccountAccessTokensid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenExistsHeadAccountAccessTokensid");
        }
        const baseUrl = `/AccountAccessTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenFindById");
        }
        const baseUrl = `/AccountAccessTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenPatchOrCreate(params: {  "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountAccessToken id
     * @param refresh 
     */
    accountAccessTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenPrototypeGetUser");
        }
        const baseUrl = `/AccountAccessTokens/{id}/user`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountAccessToken id
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenPrototypePatchAttributes");
        }
        const baseUrl = `/AccountAccessTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace");
        }
        const baseUrl = `/AccountAccessTokens/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountAccessTokenReplaceByIdPutAccountAccessTokensid(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountAccessTokenReplaceByIdPutAccountAccessTokensid");
        }
        const baseUrl = `/AccountAccessTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenReplaceOrCreatePostAccountAccessTokensReplaceOrCreate(params: {  "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenReplaceOrCreatePutAccountAccessTokens(params: {  "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenUpdateAll(params: {  "where"?: string; "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountAccessToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountAccessTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountAccessTokenApi - functional programming interface
 */
export const AccountAccessTokenApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountAccessTokenCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountAccessTokenCreate(params: { "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountAccessTokenCreateChangeStreamGetAccountAccessTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenCreateChangeStreamGetAccountAccessTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountAccessTokenCreateChangeStreamPostAccountAccessTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenCreateChangeStreamPostAccountAccessTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountAccessTokenDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountAccessTokenExistsGetAccountAccessTokensidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenExistsGetAccountAccessTokensidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountAccessTokenExistsHeadAccountAccessTokensid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenExistsHeadAccountAccessTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountAccessToken>> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenPatchOrCreate(params: { "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountAccessToken id
     * @param refresh 
     */
    accountAccessTokenPrototypeGetUser(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenPrototypeGetUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountAccessToken id
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenPrototypePatchAttributes(params: { "id": string; "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace(params: { "id": string; "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountAccessTokenReplaceByIdPutAccountAccessTokensid(params: { "id": string; "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenReplaceByIdPutAccountAccessTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenReplaceOrCreatePostAccountAccessTokensReplaceOrCreate(params: { "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenReplaceOrCreatePostAccountAccessTokensReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenReplaceOrCreatePutAccountAccessTokens(params: { "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenReplaceOrCreatePutAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenUpdateAll(params: { "where"?: string; "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenUpsertWithWhere(params: { "where"?: string; "data"?: AccountAccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountAccessToken> {
        const fetchArgs = AccountAccessTokenApiFetchParamCreator.accountAccessTokenUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountAccessTokenApi - object-oriented interface
 */
export class AccountAccessTokenApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountAccessTokenCount(params: {  "where"?: string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountAccessTokenCreate(params: {  "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountAccessTokenCreateChangeStreamGetAccountAccessTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenCreateChangeStreamGetAccountAccessTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountAccessTokenCreateChangeStreamPostAccountAccessTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenCreateChangeStreamPostAccountAccessTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountAccessTokenDeleteById(params: {  "id": string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountAccessTokenExistsGetAccountAccessTokensidExists(params: {  "id": string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenExistsGetAccountAccessTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountAccessTokenExistsHeadAccountAccessTokensid(params: {  "id": string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenExistsHeadAccountAccessTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFind(params: {  "filter"?: string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountAccessTokenFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenPatchOrCreate(params: {  "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountAccessToken id
     * @param refresh 
     */
    accountAccessTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountAccessToken id
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountAccessTokenReplaceByIdPutAccountAccessTokensid(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenReplaceByIdPutAccountAccessTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenReplaceOrCreatePostAccountAccessTokensReplaceOrCreate(params: {  "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenReplaceOrCreatePostAccountAccessTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountAccessTokenReplaceOrCreatePutAccountAccessTokens(params: {  "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenReplaceOrCreatePutAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenUpdateAll(params: {  "where"?: string; "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountAccessTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountAccessToken; }, options?: any) {
        return AccountAccessTokenApiFp.accountAccessTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountAccessTokenApi - factory interface
 */
export const AccountAccessTokenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountAccessTokenCount(params: {  "where"?: string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountAccessTokenCreate(params: {  "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountAccessTokenCreateChangeStreamGetAccountAccessTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenCreateChangeStreamGetAccountAccessTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountAccessTokenCreateChangeStreamPostAccountAccessTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenCreateChangeStreamPostAccountAccessTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountAccessTokenDeleteById(params: {  "id": string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountAccessTokenExistsGetAccountAccessTokensidExists(params: {  "id": string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenExistsGetAccountAccessTokensidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountAccessTokenExistsHeadAccountAccessTokensid(params: {  "id": string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenExistsHeadAccountAccessTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountAccessTokenFind(params: {  "filter"?: string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountAccessTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountAccessTokenFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountAccessTokenPatchOrCreate(params: {  "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation user.
         * @param id AccountAccessToken id
         * @param refresh 
         */
        accountAccessTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountAccessToken id
         * @param data An object of model property name/value pairs
         */
        accountAccessTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenReplaceByIdPostAccountAccessTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountAccessTokenReplaceByIdPutAccountAccessTokensid(params: {  "id": string; "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenReplaceByIdPutAccountAccessTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountAccessTokenReplaceOrCreatePostAccountAccessTokensReplaceOrCreate(params: {  "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenReplaceOrCreatePostAccountAccessTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountAccessTokenReplaceOrCreatePutAccountAccessTokens(params: {  "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenReplaceOrCreatePutAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountAccessTokenUpdateAll(params: {  "where"?: string; "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountAccessTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountAccessToken; }, options?: any) {
            return AccountAccessTokenApiFp.accountAccessTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ApplicationApi - fetch parameter creator
 */
export const ApplicationApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    applicationCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Applications/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    applicationCreate(params: {  "data"?: Application; }, options?: any): FetchArgs {
        const baseUrl = `/Applications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    applicationCreateChangeStreamGetApplicationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Applications/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    applicationCreateChangeStreamPostApplicationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Applications/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    applicationDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling applicationDeleteById");
        }
        const baseUrl = `/Applications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    applicationExistsGetApplicationsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling applicationExistsGetApplicationsidExists");
        }
        const baseUrl = `/Applications/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    applicationExistsHeadApplicationsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling applicationExistsHeadApplicationsid");
        }
        const baseUrl = `/Applications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Applications`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling applicationFindById");
        }
        const baseUrl = `/Applications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Applications/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationPatchOrCreate(params: {  "data"?: Application; }, options?: any): FetchArgs {
        const baseUrl = `/Applications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Application id
     * @param data An object of model property name/value pairs
     */
    applicationPrototypePatchAttributes(params: {  "id": string; "data"?: Application; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling applicationPrototypePatchAttributes");
        }
        const baseUrl = `/Applications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    applicationReplaceByIdPostApplicationsidReplace(params: {  "id": string; "data"?: Application; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling applicationReplaceByIdPostApplicationsidReplace");
        }
        const baseUrl = `/Applications/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    applicationReplaceByIdPutApplicationsid(params: {  "id": string; "data"?: Application; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling applicationReplaceByIdPutApplicationsid");
        }
        const baseUrl = `/Applications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationReplaceOrCreatePostApplicationsReplaceOrCreate(params: {  "data"?: Application; }, options?: any): FetchArgs {
        const baseUrl = `/Applications/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationReplaceOrCreatePutApplications(params: {  "data"?: Application; }, options?: any): FetchArgs {
        const baseUrl = `/Applications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    applicationUpdateAll(params: {  "where"?: string; "data"?: Application; }, options?: any): FetchArgs {
        const baseUrl = `/Applications/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    applicationUpsertWithWhere(params: {  "where"?: string; "data"?: Application; }, options?: any): FetchArgs {
        const baseUrl = `/Applications/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ApplicationApi - functional programming interface
 */
export const ApplicationApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    applicationCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    applicationCreate(params: { "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    applicationCreateChangeStreamGetApplicationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationCreateChangeStreamGetApplicationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    applicationCreateChangeStreamPostApplicationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationCreateChangeStreamPostApplicationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    applicationDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    applicationExistsGetApplicationsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationExistsGetApplicationsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    applicationExistsHeadApplicationsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationExistsHeadApplicationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Application>> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationPatchOrCreate(params: { "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Application id
     * @param data An object of model property name/value pairs
     */
    applicationPrototypePatchAttributes(params: { "id": string; "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    applicationReplaceByIdPostApplicationsidReplace(params: { "id": string; "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationReplaceByIdPostApplicationsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    applicationReplaceByIdPutApplicationsid(params: { "id": string; "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationReplaceByIdPutApplicationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationReplaceOrCreatePostApplicationsReplaceOrCreate(params: { "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationReplaceOrCreatePostApplicationsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationReplaceOrCreatePutApplications(params: { "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationReplaceOrCreatePutApplications(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    applicationUpdateAll(params: { "where"?: string; "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    applicationUpsertWithWhere(params: { "where"?: string; "data"?: Application;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
        const fetchArgs = ApplicationApiFetchParamCreator.applicationUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ApplicationApi - object-oriented interface
 */
export class ApplicationApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    applicationCount(params: {  "where"?: string; }, options?: any) {
        return ApplicationApiFp.applicationCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    applicationCreate(params: {  "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    applicationCreateChangeStreamGetApplicationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ApplicationApiFp.applicationCreateChangeStreamGetApplicationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    applicationCreateChangeStreamPostApplicationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ApplicationApiFp.applicationCreateChangeStreamPostApplicationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    applicationDeleteById(params: {  "id": string; }, options?: any) {
        return ApplicationApiFp.applicationDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    applicationExistsGetApplicationsidExists(params: {  "id": string; }, options?: any) {
        return ApplicationApiFp.applicationExistsGetApplicationsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    applicationExistsHeadApplicationsid(params: {  "id": string; }, options?: any) {
        return ApplicationApiFp.applicationExistsHeadApplicationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFind(params: {  "filter"?: string; }, options?: any) {
        return ApplicationApiFp.applicationFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return ApplicationApiFp.applicationFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    applicationFindOne(params: {  "filter"?: string; }, options?: any) {
        return ApplicationApiFp.applicationFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationPatchOrCreate(params: {  "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Application id
     * @param data An object of model property name/value pairs
     */
    applicationPrototypePatchAttributes(params: {  "id": string; "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    applicationReplaceByIdPostApplicationsidReplace(params: {  "id": string; "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationReplaceByIdPostApplicationsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    applicationReplaceByIdPutApplicationsid(params: {  "id": string; "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationReplaceByIdPutApplicationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationReplaceOrCreatePostApplicationsReplaceOrCreate(params: {  "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationReplaceOrCreatePostApplicationsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    applicationReplaceOrCreatePutApplications(params: {  "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationReplaceOrCreatePutApplications(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    applicationUpdateAll(params: {  "where"?: string; "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    applicationUpsertWithWhere(params: {  "where"?: string; "data"?: Application; }, options?: any) {
        return ApplicationApiFp.applicationUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ApplicationApi - factory interface
 */
export const ApplicationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        applicationCount(params: {  "where"?: string; }, options?: any) {
            return ApplicationApiFp.applicationCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        applicationCreate(params: {  "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        applicationCreateChangeStreamGetApplicationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ApplicationApiFp.applicationCreateChangeStreamGetApplicationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        applicationCreateChangeStreamPostApplicationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ApplicationApiFp.applicationCreateChangeStreamPostApplicationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        applicationDeleteById(params: {  "id": string; }, options?: any) {
            return ApplicationApiFp.applicationDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        applicationExistsGetApplicationsidExists(params: {  "id": string; }, options?: any) {
            return ApplicationApiFp.applicationExistsGetApplicationsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        applicationExistsHeadApplicationsid(params: {  "id": string; }, options?: any) {
            return ApplicationApiFp.applicationExistsHeadApplicationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        applicationFind(params: {  "filter"?: string; }, options?: any) {
            return ApplicationApiFp.applicationFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        applicationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return ApplicationApiFp.applicationFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        applicationFindOne(params: {  "filter"?: string; }, options?: any) {
            return ApplicationApiFp.applicationFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        applicationPatchOrCreate(params: {  "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Application id
         * @param data An object of model property name/value pairs
         */
        applicationPrototypePatchAttributes(params: {  "id": string; "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        applicationReplaceByIdPostApplicationsidReplace(params: {  "id": string; "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationReplaceByIdPostApplicationsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        applicationReplaceByIdPutApplicationsid(params: {  "id": string; "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationReplaceByIdPutApplicationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        applicationReplaceOrCreatePostApplicationsReplaceOrCreate(params: {  "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationReplaceOrCreatePostApplicationsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        applicationReplaceOrCreatePutApplications(params: {  "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationReplaceOrCreatePutApplications(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        applicationUpdateAll(params: {  "where"?: string; "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        applicationUpsertWithWhere(params: {  "where"?: string; "data"?: Application; }, options?: any) {
            return ApplicationApiFp.applicationUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * AskApi - fetch parameter creator
 */
export const AskApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    askCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Asks/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    askCreate(params: {  "data"?: Ask; }, options?: any): FetchArgs {
        const baseUrl = `/Asks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    askCreateChangeStreamGetAsksChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Asks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    askCreateChangeStreamPostAsksChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Asks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    askDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling askDeleteById");
        }
        const baseUrl = `/Asks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    askExistsGetAsksidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling askExistsGetAsksidExists");
        }
        const baseUrl = `/Asks/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    askExistsHeadAsksid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling askExistsHeadAsksid");
        }
        const baseUrl = `/Asks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Asks`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling askFindById");
        }
        const baseUrl = `/Asks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Asks/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askPatchOrCreate(params: {  "data"?: Ask; }, options?: any): FetchArgs {
        const baseUrl = `/Asks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Ask id
     * @param data An object of model property name/value pairs
     */
    askPrototypePatchAttributes(params: {  "id": string; "data"?: Ask; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling askPrototypePatchAttributes");
        }
        const baseUrl = `/Asks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    askReplaceByIdPostAsksidReplace(params: {  "id": string; "data"?: Ask; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling askReplaceByIdPostAsksidReplace");
        }
        const baseUrl = `/Asks/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    askReplaceByIdPutAsksid(params: {  "id": string; "data"?: Ask; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling askReplaceByIdPutAsksid");
        }
        const baseUrl = `/Asks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askReplaceOrCreatePostAsksReplaceOrCreate(params: {  "data"?: Ask; }, options?: any): FetchArgs {
        const baseUrl = `/Asks/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askReplaceOrCreatePutAsks(params: {  "data"?: Ask; }, options?: any): FetchArgs {
        const baseUrl = `/Asks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    askUpdateAll(params: {  "where"?: string; "data"?: Ask; }, options?: any): FetchArgs {
        const baseUrl = `/Asks/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    askUpsertWithWhere(params: {  "where"?: string; "data"?: Ask; }, options?: any): FetchArgs {
        const baseUrl = `/Asks/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AskApi - functional programming interface
 */
export const AskApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    askCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AskApiFetchParamCreator.askCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    askCreate(params: { "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    askCreateChangeStreamGetAsksChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AskApiFetchParamCreator.askCreateChangeStreamGetAsksChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    askCreateChangeStreamPostAsksChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AskApiFetchParamCreator.askCreateChangeStreamPostAsksChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    askDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AskApiFetchParamCreator.askDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    askExistsGetAsksidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AskApiFetchParamCreator.askExistsGetAsksidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    askExistsHeadAsksid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AskApiFetchParamCreator.askExistsHeadAsksid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Ask>> {
        const fetchArgs = AskApiFetchParamCreator.askFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askPatchOrCreate(params: { "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Ask id
     * @param data An object of model property name/value pairs
     */
    askPrototypePatchAttributes(params: { "id": string; "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    askReplaceByIdPostAsksidReplace(params: { "id": string; "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askReplaceByIdPostAsksidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    askReplaceByIdPutAsksid(params: { "id": string; "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askReplaceByIdPutAsksid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askReplaceOrCreatePostAsksReplaceOrCreate(params: { "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askReplaceOrCreatePostAsksReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askReplaceOrCreatePutAsks(params: { "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askReplaceOrCreatePutAsks(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    askUpdateAll(params: { "where"?: string; "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AskApiFetchParamCreator.askUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    askUpsertWithWhere(params: { "where"?: string; "data"?: Ask;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ask> {
        const fetchArgs = AskApiFetchParamCreator.askUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AskApi - object-oriented interface
 */
export class AskApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    askCount(params: {  "where"?: string; }, options?: any) {
        return AskApiFp.askCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    askCreate(params: {  "data"?: Ask; }, options?: any) {
        return AskApiFp.askCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    askCreateChangeStreamGetAsksChangeStream(params: {  "options"?: string; }, options?: any) {
        return AskApiFp.askCreateChangeStreamGetAsksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    askCreateChangeStreamPostAsksChangeStream(params: {  "options"?: string; }, options?: any) {
        return AskApiFp.askCreateChangeStreamPostAsksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    askDeleteById(params: {  "id": string; }, options?: any) {
        return AskApiFp.askDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    askExistsGetAsksidExists(params: {  "id": string; }, options?: any) {
        return AskApiFp.askExistsGetAsksidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    askExistsHeadAsksid(params: {  "id": string; }, options?: any) {
        return AskApiFp.askExistsHeadAsksid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFind(params: {  "filter"?: string; }, options?: any) {
        return AskApiFp.askFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AskApiFp.askFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    askFindOne(params: {  "filter"?: string; }, options?: any) {
        return AskApiFp.askFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askPatchOrCreate(params: {  "data"?: Ask; }, options?: any) {
        return AskApiFp.askPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Ask id
     * @param data An object of model property name/value pairs
     */
    askPrototypePatchAttributes(params: {  "id": string; "data"?: Ask; }, options?: any) {
        return AskApiFp.askPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    askReplaceByIdPostAsksidReplace(params: {  "id": string; "data"?: Ask; }, options?: any) {
        return AskApiFp.askReplaceByIdPostAsksidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    askReplaceByIdPutAsksid(params: {  "id": string; "data"?: Ask; }, options?: any) {
        return AskApiFp.askReplaceByIdPutAsksid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askReplaceOrCreatePostAsksReplaceOrCreate(params: {  "data"?: Ask; }, options?: any) {
        return AskApiFp.askReplaceOrCreatePostAsksReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    askReplaceOrCreatePutAsks(params: {  "data"?: Ask; }, options?: any) {
        return AskApiFp.askReplaceOrCreatePutAsks(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    askUpdateAll(params: {  "where"?: string; "data"?: Ask; }, options?: any) {
        return AskApiFp.askUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    askUpsertWithWhere(params: {  "where"?: string; "data"?: Ask; }, options?: any) {
        return AskApiFp.askUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AskApi - factory interface
 */
export const AskApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        askCount(params: {  "where"?: string; }, options?: any) {
            return AskApiFp.askCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        askCreate(params: {  "data"?: Ask; }, options?: any) {
            return AskApiFp.askCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        askCreateChangeStreamGetAsksChangeStream(params: {  "options"?: string; }, options?: any) {
            return AskApiFp.askCreateChangeStreamGetAsksChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        askCreateChangeStreamPostAsksChangeStream(params: {  "options"?: string; }, options?: any) {
            return AskApiFp.askCreateChangeStreamPostAsksChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        askDeleteById(params: {  "id": string; }, options?: any) {
            return AskApiFp.askDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        askExistsGetAsksidExists(params: {  "id": string; }, options?: any) {
            return AskApiFp.askExistsGetAsksidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        askExistsHeadAsksid(params: {  "id": string; }, options?: any) {
            return AskApiFp.askExistsHeadAsksid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        askFind(params: {  "filter"?: string; }, options?: any) {
            return AskApiFp.askFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        askFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AskApiFp.askFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        askFindOne(params: {  "filter"?: string; }, options?: any) {
            return AskApiFp.askFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        askPatchOrCreate(params: {  "data"?: Ask; }, options?: any) {
            return AskApiFp.askPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Ask id
         * @param data An object of model property name/value pairs
         */
        askPrototypePatchAttributes(params: {  "id": string; "data"?: Ask; }, options?: any) {
            return AskApiFp.askPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        askReplaceByIdPostAsksidReplace(params: {  "id": string; "data"?: Ask; }, options?: any) {
            return AskApiFp.askReplaceByIdPostAsksidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        askReplaceByIdPutAsksid(params: {  "id": string; "data"?: Ask; }, options?: any) {
            return AskApiFp.askReplaceByIdPutAsksid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        askReplaceOrCreatePostAsksReplaceOrCreate(params: {  "data"?: Ask; }, options?: any) {
            return AskApiFp.askReplaceOrCreatePostAsksReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        askReplaceOrCreatePutAsks(params: {  "data"?: Ask; }, options?: any) {
            return AskApiFp.askReplaceOrCreatePutAsks(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        askUpdateAll(params: {  "where"?: string; "data"?: Ask; }, options?: any) {
            return AskApiFp.askUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        askUpsertWithWhere(params: {  "where"?: string; "data"?: Ask; }, options?: any) {
            return AskApiFp.askUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyApi - fetch parameter creator
 */
export const CompanyApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    companyCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Companies/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    companyCreate(params: {  "data"?: Company; }, options?: any): FetchArgs {
        const baseUrl = `/Companies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    companyCreateChangeStreamGetCompaniesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Companies/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    companyCreateChangeStreamPostCompaniesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Companies/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    companyDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling companyDeleteById");
        }
        const baseUrl = `/Companies/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    companyExistsGetCompaniesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling companyExistsGetCompaniesidExists");
        }
        const baseUrl = `/Companies/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    companyExistsHeadCompaniesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling companyExistsHeadCompaniesid");
        }
        const baseUrl = `/Companies/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Companies`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling companyFindById");
        }
        const baseUrl = `/Companies/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Companies/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyPatchOrCreate(params: {  "data"?: Company; }, options?: any): FetchArgs {
        const baseUrl = `/Companies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Company id
     * @param data An object of model property name/value pairs
     */
    companyPrototypePatchAttributes(params: {  "id": string; "data"?: Company; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling companyPrototypePatchAttributes");
        }
        const baseUrl = `/Companies/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    companyReplaceByIdPostCompaniesidReplace(params: {  "id": string; "data"?: Company; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling companyReplaceByIdPostCompaniesidReplace");
        }
        const baseUrl = `/Companies/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    companyReplaceByIdPutCompaniesid(params: {  "id": string; "data"?: Company; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling companyReplaceByIdPutCompaniesid");
        }
        const baseUrl = `/Companies/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyReplaceOrCreatePostCompaniesReplaceOrCreate(params: {  "data"?: Company; }, options?: any): FetchArgs {
        const baseUrl = `/Companies/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyReplaceOrCreatePutCompanies(params: {  "data"?: Company; }, options?: any): FetchArgs {
        const baseUrl = `/Companies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    companyUpdateAll(params: {  "where"?: string; "data"?: Company; }, options?: any): FetchArgs {
        const baseUrl = `/Companies/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    companyUpsertWithWhere(params: {  "where"?: string; "data"?: Company; }, options?: any): FetchArgs {
        const baseUrl = `/Companies/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyApi - functional programming interface
 */
export const CompanyApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    companyCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = CompanyApiFetchParamCreator.companyCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    companyCreate(params: { "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    companyCreateChangeStreamGetCompaniesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyApiFetchParamCreator.companyCreateChangeStreamGetCompaniesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    companyCreateChangeStreamPostCompaniesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyApiFetchParamCreator.companyCreateChangeStreamPostCompaniesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    companyDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyApiFetchParamCreator.companyDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    companyExistsGetCompaniesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = CompanyApiFetchParamCreator.companyExistsGetCompaniesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    companyExistsHeadCompaniesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = CompanyApiFetchParamCreator.companyExistsHeadCompaniesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Company>> {
        const fetchArgs = CompanyApiFetchParamCreator.companyFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyPatchOrCreate(params: { "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Company id
     * @param data An object of model property name/value pairs
     */
    companyPrototypePatchAttributes(params: { "id": string; "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    companyReplaceByIdPostCompaniesidReplace(params: { "id": string; "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyReplaceByIdPostCompaniesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    companyReplaceByIdPutCompaniesid(params: { "id": string; "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyReplaceByIdPutCompaniesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyReplaceOrCreatePostCompaniesReplaceOrCreate(params: { "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyReplaceOrCreatePostCompaniesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyReplaceOrCreatePutCompanies(params: { "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyReplaceOrCreatePutCompanies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    companyUpdateAll(params: { "where"?: string; "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = CompanyApiFetchParamCreator.companyUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    companyUpsertWithWhere(params: { "where"?: string; "data"?: Company;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.companyUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyApi - object-oriented interface
 */
export class CompanyApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    companyCount(params: {  "where"?: string; }, options?: any) {
        return CompanyApiFp.companyCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    companyCreate(params: {  "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    companyCreateChangeStreamGetCompaniesChangeStream(params: {  "options"?: string; }, options?: any) {
        return CompanyApiFp.companyCreateChangeStreamGetCompaniesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    companyCreateChangeStreamPostCompaniesChangeStream(params: {  "options"?: string; }, options?: any) {
        return CompanyApiFp.companyCreateChangeStreamPostCompaniesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    companyDeleteById(params: {  "id": string; }, options?: any) {
        return CompanyApiFp.companyDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    companyExistsGetCompaniesidExists(params: {  "id": string; }, options?: any) {
        return CompanyApiFp.companyExistsGetCompaniesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    companyExistsHeadCompaniesid(params: {  "id": string; }, options?: any) {
        return CompanyApiFp.companyExistsHeadCompaniesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFind(params: {  "filter"?: string; }, options?: any) {
        return CompanyApiFp.companyFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return CompanyApiFp.companyFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    companyFindOne(params: {  "filter"?: string; }, options?: any) {
        return CompanyApiFp.companyFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyPatchOrCreate(params: {  "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Company id
     * @param data An object of model property name/value pairs
     */
    companyPrototypePatchAttributes(params: {  "id": string; "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    companyReplaceByIdPostCompaniesidReplace(params: {  "id": string; "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyReplaceByIdPostCompaniesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    companyReplaceByIdPutCompaniesid(params: {  "id": string; "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyReplaceByIdPutCompaniesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyReplaceOrCreatePostCompaniesReplaceOrCreate(params: {  "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyReplaceOrCreatePostCompaniesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    companyReplaceOrCreatePutCompanies(params: {  "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyReplaceOrCreatePutCompanies(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    companyUpdateAll(params: {  "where"?: string; "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    companyUpsertWithWhere(params: {  "where"?: string; "data"?: Company; }, options?: any) {
        return CompanyApiFp.companyUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyApi - factory interface
 */
export const CompanyApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        companyCount(params: {  "where"?: string; }, options?: any) {
            return CompanyApiFp.companyCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        companyCreate(params: {  "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        companyCreateChangeStreamGetCompaniesChangeStream(params: {  "options"?: string; }, options?: any) {
            return CompanyApiFp.companyCreateChangeStreamGetCompaniesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        companyCreateChangeStreamPostCompaniesChangeStream(params: {  "options"?: string; }, options?: any) {
            return CompanyApiFp.companyCreateChangeStreamPostCompaniesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        companyDeleteById(params: {  "id": string; }, options?: any) {
            return CompanyApiFp.companyDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        companyExistsGetCompaniesidExists(params: {  "id": string; }, options?: any) {
            return CompanyApiFp.companyExistsGetCompaniesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        companyExistsHeadCompaniesid(params: {  "id": string; }, options?: any) {
            return CompanyApiFp.companyExistsHeadCompaniesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        companyFind(params: {  "filter"?: string; }, options?: any) {
            return CompanyApiFp.companyFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        companyFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return CompanyApiFp.companyFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        companyFindOne(params: {  "filter"?: string; }, options?: any) {
            return CompanyApiFp.companyFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        companyPatchOrCreate(params: {  "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Company id
         * @param data An object of model property name/value pairs
         */
        companyPrototypePatchAttributes(params: {  "id": string; "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        companyReplaceByIdPostCompaniesidReplace(params: {  "id": string; "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyReplaceByIdPostCompaniesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        companyReplaceByIdPutCompaniesid(params: {  "id": string; "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyReplaceByIdPutCompaniesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        companyReplaceOrCreatePostCompaniesReplaceOrCreate(params: {  "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyReplaceOrCreatePostCompaniesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        companyReplaceOrCreatePutCompanies(params: {  "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyReplaceOrCreatePutCompanies(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        companyUpdateAll(params: {  "where"?: string; "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        companyUpsertWithWhere(params: {  "where"?: string; "data"?: Company; }, options?: any) {
            return CompanyApiFp.companyUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContainerApi - fetch parameter creator
 */
export const ContainerApiFetchParamCreator = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContainerApi - functional programming interface
 */
export const ContainerApiFp = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: { "options"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContainerApi - object-oriented interface
 */
export class ContainerApi extends BaseAPI {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any) {
        return ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    containerGetContainers(options?: any) {
        return ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContainerApi - factory interface
 */
export const ContainerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param options 
         */
        containerCreateContainer(params: {  "options"?: any; }, options?: any) {
            return ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerDestroyContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerDownload(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        containerGetContainers(options?: any) {
            return ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetFiles(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerUpload(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};


/**
 * CourseApi - fetch parameter creator
 */
export const CourseApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    courseCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Courses/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    courseCreate(params: {  "data"?: Course; }, options?: any): FetchArgs {
        const baseUrl = `/Courses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    courseCreateChangeStreamGetCoursesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Courses/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    courseCreateChangeStreamPostCoursesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Courses/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    courseDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling courseDeleteById");
        }
        const baseUrl = `/Courses/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    courseExistsGetCoursesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling courseExistsGetCoursesidExists");
        }
        const baseUrl = `/Courses/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    courseExistsHeadCoursesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling courseExistsHeadCoursesid");
        }
        const baseUrl = `/Courses/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Courses`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling courseFindById");
        }
        const baseUrl = `/Courses/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Courses/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    coursePatchOrCreate(params: {  "data"?: Course; }, options?: any): FetchArgs {
        const baseUrl = `/Courses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Course id
     * @param data An object of model property name/value pairs
     */
    coursePrototypePatchAttributes(params: {  "id": string; "data"?: Course; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling coursePrototypePatchAttributes");
        }
        const baseUrl = `/Courses/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    courseReplaceByIdPostCoursesidReplace(params: {  "id": string; "data"?: Course; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling courseReplaceByIdPostCoursesidReplace");
        }
        const baseUrl = `/Courses/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    courseReplaceByIdPutCoursesid(params: {  "id": string; "data"?: Course; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling courseReplaceByIdPutCoursesid");
        }
        const baseUrl = `/Courses/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    courseReplaceOrCreatePostCoursesReplaceOrCreate(params: {  "data"?: Course; }, options?: any): FetchArgs {
        const baseUrl = `/Courses/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    courseReplaceOrCreatePutCourses(params: {  "data"?: Course; }, options?: any): FetchArgs {
        const baseUrl = `/Courses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    courseUpdateAll(params: {  "where"?: string; "data"?: Course; }, options?: any): FetchArgs {
        const baseUrl = `/Courses/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    courseUpsertWithWhere(params: {  "where"?: string; "data"?: Course; }, options?: any): FetchArgs {
        const baseUrl = `/Courses/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CourseApi - functional programming interface
 */
export const CourseApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    courseCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = CourseApiFetchParamCreator.courseCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    courseCreate(params: { "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    courseCreateChangeStreamGetCoursesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CourseApiFetchParamCreator.courseCreateChangeStreamGetCoursesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    courseCreateChangeStreamPostCoursesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CourseApiFetchParamCreator.courseCreateChangeStreamPostCoursesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    courseDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CourseApiFetchParamCreator.courseDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    courseExistsGetCoursesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = CourseApiFetchParamCreator.courseExistsGetCoursesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    courseExistsHeadCoursesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = CourseApiFetchParamCreator.courseExistsHeadCoursesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Course>> {
        const fetchArgs = CourseApiFetchParamCreator.courseFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    coursePatchOrCreate(params: { "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.coursePatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Course id
     * @param data An object of model property name/value pairs
     */
    coursePrototypePatchAttributes(params: { "id": string; "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.coursePrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    courseReplaceByIdPostCoursesidReplace(params: { "id": string; "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseReplaceByIdPostCoursesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    courseReplaceByIdPutCoursesid(params: { "id": string; "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseReplaceByIdPutCoursesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    courseReplaceOrCreatePostCoursesReplaceOrCreate(params: { "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseReplaceOrCreatePostCoursesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    courseReplaceOrCreatePutCourses(params: { "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseReplaceOrCreatePutCourses(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    courseUpdateAll(params: { "where"?: string; "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = CourseApiFetchParamCreator.courseUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    courseUpsertWithWhere(params: { "where"?: string; "data"?: Course;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Course> {
        const fetchArgs = CourseApiFetchParamCreator.courseUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CourseApi - object-oriented interface
 */
export class CourseApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    courseCount(params: {  "where"?: string; }, options?: any) {
        return CourseApiFp.courseCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    courseCreate(params: {  "data"?: Course; }, options?: any) {
        return CourseApiFp.courseCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    courseCreateChangeStreamGetCoursesChangeStream(params: {  "options"?: string; }, options?: any) {
        return CourseApiFp.courseCreateChangeStreamGetCoursesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    courseCreateChangeStreamPostCoursesChangeStream(params: {  "options"?: string; }, options?: any) {
        return CourseApiFp.courseCreateChangeStreamPostCoursesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    courseDeleteById(params: {  "id": string; }, options?: any) {
        return CourseApiFp.courseDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    courseExistsGetCoursesidExists(params: {  "id": string; }, options?: any) {
        return CourseApiFp.courseExistsGetCoursesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    courseExistsHeadCoursesid(params: {  "id": string; }, options?: any) {
        return CourseApiFp.courseExistsHeadCoursesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFind(params: {  "filter"?: string; }, options?: any) {
        return CourseApiFp.courseFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return CourseApiFp.courseFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    courseFindOne(params: {  "filter"?: string; }, options?: any) {
        return CourseApiFp.courseFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    coursePatchOrCreate(params: {  "data"?: Course; }, options?: any) {
        return CourseApiFp.coursePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Course id
     * @param data An object of model property name/value pairs
     */
    coursePrototypePatchAttributes(params: {  "id": string; "data"?: Course; }, options?: any) {
        return CourseApiFp.coursePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    courseReplaceByIdPostCoursesidReplace(params: {  "id": string; "data"?: Course; }, options?: any) {
        return CourseApiFp.courseReplaceByIdPostCoursesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    courseReplaceByIdPutCoursesid(params: {  "id": string; "data"?: Course; }, options?: any) {
        return CourseApiFp.courseReplaceByIdPutCoursesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    courseReplaceOrCreatePostCoursesReplaceOrCreate(params: {  "data"?: Course; }, options?: any) {
        return CourseApiFp.courseReplaceOrCreatePostCoursesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    courseReplaceOrCreatePutCourses(params: {  "data"?: Course; }, options?: any) {
        return CourseApiFp.courseReplaceOrCreatePutCourses(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    courseUpdateAll(params: {  "where"?: string; "data"?: Course; }, options?: any) {
        return CourseApiFp.courseUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    courseUpsertWithWhere(params: {  "where"?: string; "data"?: Course; }, options?: any) {
        return CourseApiFp.courseUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CourseApi - factory interface
 */
export const CourseApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        courseCount(params: {  "where"?: string; }, options?: any) {
            return CourseApiFp.courseCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        courseCreate(params: {  "data"?: Course; }, options?: any) {
            return CourseApiFp.courseCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        courseCreateChangeStreamGetCoursesChangeStream(params: {  "options"?: string; }, options?: any) {
            return CourseApiFp.courseCreateChangeStreamGetCoursesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        courseCreateChangeStreamPostCoursesChangeStream(params: {  "options"?: string; }, options?: any) {
            return CourseApiFp.courseCreateChangeStreamPostCoursesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        courseDeleteById(params: {  "id": string; }, options?: any) {
            return CourseApiFp.courseDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        courseExistsGetCoursesidExists(params: {  "id": string; }, options?: any) {
            return CourseApiFp.courseExistsGetCoursesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        courseExistsHeadCoursesid(params: {  "id": string; }, options?: any) {
            return CourseApiFp.courseExistsHeadCoursesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        courseFind(params: {  "filter"?: string; }, options?: any) {
            return CourseApiFp.courseFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        courseFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return CourseApiFp.courseFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        courseFindOne(params: {  "filter"?: string; }, options?: any) {
            return CourseApiFp.courseFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        coursePatchOrCreate(params: {  "data"?: Course; }, options?: any) {
            return CourseApiFp.coursePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Course id
         * @param data An object of model property name/value pairs
         */
        coursePrototypePatchAttributes(params: {  "id": string; "data"?: Course; }, options?: any) {
            return CourseApiFp.coursePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        courseReplaceByIdPostCoursesidReplace(params: {  "id": string; "data"?: Course; }, options?: any) {
            return CourseApiFp.courseReplaceByIdPostCoursesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        courseReplaceByIdPutCoursesid(params: {  "id": string; "data"?: Course; }, options?: any) {
            return CourseApiFp.courseReplaceByIdPutCoursesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        courseReplaceOrCreatePostCoursesReplaceOrCreate(params: {  "data"?: Course; }, options?: any) {
            return CourseApiFp.courseReplaceOrCreatePostCoursesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        courseReplaceOrCreatePutCourses(params: {  "data"?: Course; }, options?: any) {
            return CourseApiFp.courseReplaceOrCreatePutCourses(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        courseUpdateAll(params: {  "where"?: string; "data"?: Course; }, options?: any) {
            return CourseApiFp.courseUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        courseUpsertWithWhere(params: {  "where"?: string; "data"?: Course; }, options?: any) {
            return CourseApiFp.courseUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * FaqApi - fetch parameter creator
 */
export const FaqApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    faqCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    faqCreate(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamGetFaqsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamPostFaqsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    faqDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqDeleteById");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsGetFaqsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqExistsGetFaqsidExists");
        }
        const baseUrl = `/Faqs/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsHeadFaqsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqExistsHeadFaqsid");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqFindById");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqPatchOrCreate(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Faq id
     * @param data An object of model property name/value pairs
     */
    faqPrototypePatchAttributes(params: {  "id": string; "data"?: Faq; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqPrototypePatchAttributes");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPostFaqsidReplace(params: {  "id": string; "data"?: Faq; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqReplaceByIdPostFaqsidReplace");
        }
        const baseUrl = `/Faqs/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPutFaqsid(params: {  "id": string; "data"?: Faq; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqReplaceByIdPutFaqsid");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePostFaqsReplaceOrCreate(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePutFaqs(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpdateAll(params: {  "where"?: string; "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpsertWithWhere(params: {  "where"?: string; "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FaqApi - functional programming interface
 */
export const FaqApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    faqCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = FaqApiFetchParamCreator.faqCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    faqCreate(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamGetFaqsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FaqApiFetchParamCreator.faqCreateChangeStreamGetFaqsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamPostFaqsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FaqApiFetchParamCreator.faqCreateChangeStreamPostFaqsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    faqDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FaqApiFetchParamCreator.faqDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsGetFaqsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = FaqApiFetchParamCreator.faqExistsGetFaqsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsHeadFaqsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = FaqApiFetchParamCreator.faqExistsHeadFaqsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Faq>> {
        const fetchArgs = FaqApiFetchParamCreator.faqFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqPatchOrCreate(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Faq id
     * @param data An object of model property name/value pairs
     */
    faqPrototypePatchAttributes(params: { "id": string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPostFaqsidReplace(params: { "id": string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceByIdPostFaqsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPutFaqsid(params: { "id": string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceByIdPutFaqsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePostFaqsReplaceOrCreate(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceOrCreatePostFaqsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePutFaqs(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceOrCreatePutFaqs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpdateAll(params: { "where"?: string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = FaqApiFetchParamCreator.faqUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpsertWithWhere(params: { "where"?: string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FaqApi - object-oriented interface
 */
export class FaqApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    faqCount(params: {  "where"?: string; }, options?: any) {
        return FaqApiFp.faqCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    faqCreate(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamGetFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
        return FaqApiFp.faqCreateChangeStreamGetFaqsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamPostFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
        return FaqApiFp.faqCreateChangeStreamPostFaqsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    faqDeleteById(params: {  "id": string; }, options?: any) {
        return FaqApiFp.faqDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsGetFaqsidExists(params: {  "id": string; }, options?: any) {
        return FaqApiFp.faqExistsGetFaqsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsHeadFaqsid(params: {  "id": string; }, options?: any) {
        return FaqApiFp.faqExistsHeadFaqsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFind(params: {  "filter"?: string; }, options?: any) {
        return FaqApiFp.faqFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return FaqApiFp.faqFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindOne(params: {  "filter"?: string; }, options?: any) {
        return FaqApiFp.faqFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqPatchOrCreate(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Faq id
     * @param data An object of model property name/value pairs
     */
    faqPrototypePatchAttributes(params: {  "id": string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPostFaqsidReplace(params: {  "id": string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceByIdPostFaqsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPutFaqsid(params: {  "id": string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceByIdPutFaqsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePostFaqsReplaceOrCreate(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceOrCreatePostFaqsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePutFaqs(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceOrCreatePutFaqs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpdateAll(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpsertWithWhere(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * FaqApi - factory interface
 */
export const FaqApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        faqCount(params: {  "where"?: string; }, options?: any) {
            return FaqApiFp.faqCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        faqCreate(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        faqCreateChangeStreamGetFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
            return FaqApiFp.faqCreateChangeStreamGetFaqsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        faqCreateChangeStreamPostFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
            return FaqApiFp.faqCreateChangeStreamPostFaqsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        faqDeleteById(params: {  "id": string; }, options?: any) {
            return FaqApiFp.faqDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        faqExistsGetFaqsidExists(params: {  "id": string; }, options?: any) {
            return FaqApiFp.faqExistsGetFaqsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        faqExistsHeadFaqsid(params: {  "id": string; }, options?: any) {
            return FaqApiFp.faqExistsHeadFaqsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        faqFind(params: {  "filter"?: string; }, options?: any) {
            return FaqApiFp.faqFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        faqFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return FaqApiFp.faqFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        faqFindOne(params: {  "filter"?: string; }, options?: any) {
            return FaqApiFp.faqFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        faqPatchOrCreate(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Faq id
         * @param data An object of model property name/value pairs
         */
        faqPrototypePatchAttributes(params: {  "id": string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        faqReplaceByIdPostFaqsidReplace(params: {  "id": string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceByIdPostFaqsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        faqReplaceByIdPutFaqsid(params: {  "id": string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceByIdPutFaqsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        faqReplaceOrCreatePostFaqsReplaceOrCreate(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceOrCreatePostFaqsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        faqReplaceOrCreatePutFaqs(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceOrCreatePutFaqs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        faqUpdateAll(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        faqUpsertWithWhere(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * InstallationApi - fetch parameter creator
 */
export const InstallationApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    installationCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    installationCreate(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamGetInstallationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamPostInstallationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    installationDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationDeleteById");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsGetInstallationsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationExistsGetInstallationsidExists");
        }
        const baseUrl = `/Installations/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsHeadInstallationsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationExistsHeadInstallationsid");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find installations by application id
     * @param deviceType Device type
     * @param appId Application id
     * @param appVersion Application version
     */
    installationFindByApp(params: {  "deviceType"?: string; "appId"?: string; "appVersion"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/byApp`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "deviceType": params["deviceType"],
            "appId": params["appId"],
            "appVersion": params["appVersion"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationFindById");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find installations by subscriptions
     * @param deviceType Device type
     * @param subscriptions Subscriptions
     */
    installationFindBySubscriptions(params: {  "deviceType"?: string; "subscriptions"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/bySubscriptions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "deviceType": params["deviceType"],
            "subscriptions": params["subscriptions"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find installations by user id
     * @param deviceType Device type
     * @param userId User id
     */
    installationFindByUser(params: {  "deviceType"?: string; "userId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/byUser`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "deviceType": params["deviceType"],
            "userId": params["userId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationPatchOrCreate(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Installation id
     * @param data An object of model property name/value pairs
     */
    installationPrototypePatchAttributes(params: {  "id": string; "data"?: Installation; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationPrototypePatchAttributes");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPostInstallationsidReplace(params: {  "id": string; "data"?: Installation; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationReplaceByIdPostInstallationsidReplace");
        }
        const baseUrl = `/Installations/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPutInstallationsid(params: {  "id": string; "data"?: Installation; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationReplaceByIdPutInstallationsid");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePutInstallations(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpdateAll(params: {  "where"?: string; "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpsertWithWhere(params: {  "where"?: string; "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InstallationApi - functional programming interface
 */
export const InstallationApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    installationCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    installationCreate(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamGetInstallationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCreateChangeStreamGetInstallationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamPostInstallationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCreateChangeStreamPostInstallationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    installationDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsGetInstallationsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = InstallationApiFetchParamCreator.installationExistsGetInstallationsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsHeadInstallationsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = InstallationApiFetchParamCreator.installationExistsHeadInstallationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Installation>> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find installations by application id
     * @param deviceType Device type
     * @param appId Application id
     * @param appVersion Application version
     */
    installationFindByApp(params: { "deviceType"?: string; "appId"?: string; "appVersion"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindByApp(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find installations by subscriptions
     * @param deviceType Device type
     * @param subscriptions Subscriptions
     */
    installationFindBySubscriptions(params: { "deviceType"?: string; "subscriptions"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindBySubscriptions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find installations by user id
     * @param deviceType Device type
     * @param userId User id
     */
    installationFindByUser(params: { "deviceType"?: string; "userId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindByUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationPatchOrCreate(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Installation id
     * @param data An object of model property name/value pairs
     */
    installationPrototypePatchAttributes(params: { "id": string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPostInstallationsidReplace(params: { "id": string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceByIdPostInstallationsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPutInstallationsid(params: { "id": string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceByIdPutInstallationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceOrCreatePostInstallationsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePutInstallations(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceOrCreatePutInstallations(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpdateAll(params: { "where"?: string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = InstallationApiFetchParamCreator.installationUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpsertWithWhere(params: { "where"?: string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InstallationApi - object-oriented interface
 */
export class InstallationApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    installationCount(params: {  "where"?: string; }, options?: any) {
        return InstallationApiFp.installationCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    installationCreate(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamGetInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return InstallationApiFp.installationCreateChangeStreamGetInstallationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamPostInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return InstallationApiFp.installationCreateChangeStreamPostInstallationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    installationDeleteById(params: {  "id": string; }, options?: any) {
        return InstallationApiFp.installationDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsGetInstallationsidExists(params: {  "id": string; }, options?: any) {
        return InstallationApiFp.installationExistsGetInstallationsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsHeadInstallationsid(params: {  "id": string; }, options?: any) {
        return InstallationApiFp.installationExistsHeadInstallationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFind(params: {  "filter"?: string; }, options?: any) {
        return InstallationApiFp.installationFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find installations by application id
     * @param deviceType Device type
     * @param appId Application id
     * @param appVersion Application version
     */
    installationFindByApp(params: {  "deviceType"?: string; "appId"?: string; "appVersion"?: string; }, options?: any) {
        return InstallationApiFp.installationFindByApp(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return InstallationApiFp.installationFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find installations by subscriptions
     * @param deviceType Device type
     * @param subscriptions Subscriptions
     */
    installationFindBySubscriptions(params: {  "deviceType"?: string; "subscriptions"?: string; }, options?: any) {
        return InstallationApiFp.installationFindBySubscriptions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find installations by user id
     * @param deviceType Device type
     * @param userId User id
     */
    installationFindByUser(params: {  "deviceType"?: string; "userId"?: string; }, options?: any) {
        return InstallationApiFp.installationFindByUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindOne(params: {  "filter"?: string; }, options?: any) {
        return InstallationApiFp.installationFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationPatchOrCreate(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Installation id
     * @param data An object of model property name/value pairs
     */
    installationPrototypePatchAttributes(params: {  "id": string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPostInstallationsidReplace(params: {  "id": string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceByIdPostInstallationsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPutInstallationsid(params: {  "id": string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceByIdPutInstallationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceOrCreatePostInstallationsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePutInstallations(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceOrCreatePutInstallations(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpdateAll(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpsertWithWhere(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InstallationApi - factory interface
 */
export const InstallationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        installationCount(params: {  "where"?: string; }, options?: any) {
            return InstallationApiFp.installationCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        installationCreate(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        installationCreateChangeStreamGetInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return InstallationApiFp.installationCreateChangeStreamGetInstallationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        installationCreateChangeStreamPostInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return InstallationApiFp.installationCreateChangeStreamPostInstallationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        installationDeleteById(params: {  "id": string; }, options?: any) {
            return InstallationApiFp.installationDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        installationExistsGetInstallationsidExists(params: {  "id": string; }, options?: any) {
            return InstallationApiFp.installationExistsGetInstallationsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        installationExistsHeadInstallationsid(params: {  "id": string; }, options?: any) {
            return InstallationApiFp.installationExistsHeadInstallationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        installationFind(params: {  "filter"?: string; }, options?: any) {
            return InstallationApiFp.installationFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find installations by application id
         * @param deviceType Device type
         * @param appId Application id
         * @param appVersion Application version
         */
        installationFindByApp(params: {  "deviceType"?: string; "appId"?: string; "appVersion"?: string; }, options?: any) {
            return InstallationApiFp.installationFindByApp(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        installationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return InstallationApiFp.installationFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find installations by subscriptions
         * @param deviceType Device type
         * @param subscriptions Subscriptions
         */
        installationFindBySubscriptions(params: {  "deviceType"?: string; "subscriptions"?: string; }, options?: any) {
            return InstallationApiFp.installationFindBySubscriptions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find installations by user id
         * @param deviceType Device type
         * @param userId User id
         */
        installationFindByUser(params: {  "deviceType"?: string; "userId"?: string; }, options?: any) {
            return InstallationApiFp.installationFindByUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        installationFindOne(params: {  "filter"?: string; }, options?: any) {
            return InstallationApiFp.installationFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        installationPatchOrCreate(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Installation id
         * @param data An object of model property name/value pairs
         */
        installationPrototypePatchAttributes(params: {  "id": string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        installationReplaceByIdPostInstallationsidReplace(params: {  "id": string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceByIdPostInstallationsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        installationReplaceByIdPutInstallationsid(params: {  "id": string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceByIdPutInstallationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceOrCreatePostInstallationsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        installationReplaceOrCreatePutInstallations(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceOrCreatePutInstallations(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        installationUpdateAll(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        installationUpsertWithWhere(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * NotificationApi - fetch parameter creator
 */
export const NotificationApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    notificationCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    notificationCreate(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamGetNotificationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamPostNotificationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    notificationDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationDeleteById");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsGetNotificationsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationExistsGetNotificationsidExists");
        }
        const baseUrl = `/Notifications/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsHeadNotificationsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationExistsHeadNotificationsid");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationFindById");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationPatchOrCreate(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Notification id
     * @param data An object of model property name/value pairs
     */
    notificationPrototypePatchAttributes(params: {  "id": string; "data"?: Notification; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationPrototypePatchAttributes");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPostNotificationsidReplace(params: {  "id": string; "data"?: Notification; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationReplaceByIdPostNotificationsidReplace");
        }
        const baseUrl = `/Notifications/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPutNotificationsid(params: {  "id": string; "data"?: Notification; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationReplaceByIdPutNotificationsid");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePutNotifications(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpdateAll(params: {  "where"?: string; "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpsertWithWhere(params: {  "where"?: string; "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * NotificationApi - functional programming interface
 */
export const NotificationApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    notificationCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    notificationCreate(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamGetNotificationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCreateChangeStreamGetNotificationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamPostNotificationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCreateChangeStreamPostNotificationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    notificationDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsGetNotificationsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationExistsGetNotificationsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsHeadNotificationsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationExistsHeadNotificationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Notification>> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationPatchOrCreate(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Notification id
     * @param data An object of model property name/value pairs
     */
    notificationPrototypePatchAttributes(params: { "id": string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPostNotificationsidReplace(params: { "id": string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceByIdPostNotificationsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPutNotificationsid(params: { "id": string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceByIdPutNotificationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePutNotifications(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceOrCreatePutNotifications(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpdateAll(params: { "where"?: string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpsertWithWhere(params: { "where"?: string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * NotificationApi - object-oriented interface
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    notificationCount(params: {  "where"?: string; }, options?: any) {
        return NotificationApiFp.notificationCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    notificationCreate(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamGetNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return NotificationApiFp.notificationCreateChangeStreamGetNotificationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamPostNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return NotificationApiFp.notificationCreateChangeStreamPostNotificationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    notificationDeleteById(params: {  "id": string; }, options?: any) {
        return NotificationApiFp.notificationDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsGetNotificationsidExists(params: {  "id": string; }, options?: any) {
        return NotificationApiFp.notificationExistsGetNotificationsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsHeadNotificationsid(params: {  "id": string; }, options?: any) {
        return NotificationApiFp.notificationExistsHeadNotificationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFind(params: {  "filter"?: string; }, options?: any) {
        return NotificationApiFp.notificationFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return NotificationApiFp.notificationFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindOne(params: {  "filter"?: string; }, options?: any) {
        return NotificationApiFp.notificationFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationPatchOrCreate(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Notification id
     * @param data An object of model property name/value pairs
     */
    notificationPrototypePatchAttributes(params: {  "id": string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPostNotificationsidReplace(params: {  "id": string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceByIdPostNotificationsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPutNotificationsid(params: {  "id": string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceByIdPutNotificationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePutNotifications(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceOrCreatePutNotifications(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpdateAll(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpsertWithWhere(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * NotificationApi - factory interface
 */
export const NotificationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        notificationCount(params: {  "where"?: string; }, options?: any) {
            return NotificationApiFp.notificationCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        notificationCreate(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        notificationCreateChangeStreamGetNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return NotificationApiFp.notificationCreateChangeStreamGetNotificationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        notificationCreateChangeStreamPostNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return NotificationApiFp.notificationCreateChangeStreamPostNotificationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        notificationDeleteById(params: {  "id": string; }, options?: any) {
            return NotificationApiFp.notificationDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        notificationExistsGetNotificationsidExists(params: {  "id": string; }, options?: any) {
            return NotificationApiFp.notificationExistsGetNotificationsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        notificationExistsHeadNotificationsid(params: {  "id": string; }, options?: any) {
            return NotificationApiFp.notificationExistsHeadNotificationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        notificationFind(params: {  "filter"?: string; }, options?: any) {
            return NotificationApiFp.notificationFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        notificationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return NotificationApiFp.notificationFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        notificationFindOne(params: {  "filter"?: string; }, options?: any) {
            return NotificationApiFp.notificationFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        notificationPatchOrCreate(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Notification id
         * @param data An object of model property name/value pairs
         */
        notificationPrototypePatchAttributes(params: {  "id": string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        notificationReplaceByIdPostNotificationsidReplace(params: {  "id": string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceByIdPostNotificationsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        notificationReplaceByIdPutNotificationsid(params: {  "id": string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceByIdPutNotificationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        notificationReplaceOrCreatePutNotifications(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceOrCreatePutNotifications(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        notificationUpdateAll(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        notificationUpsertWithWhere(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * PostApi - fetch parameter creator
 */
export const PostApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    postCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Posts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    postCreate(params: {  "data"?: Post; }, options?: any): FetchArgs {
        const baseUrl = `/Posts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    postCreateChangeStreamGetPostsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Posts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    postCreateChangeStreamPostPostsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Posts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    postDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling postDeleteById");
        }
        const baseUrl = `/Posts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    postExistsGetPostsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling postExistsGetPostsidExists");
        }
        const baseUrl = `/Posts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    postExistsHeadPostsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling postExistsHeadPostsid");
        }
        const baseUrl = `/Posts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Posts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling postFindById");
        }
        const baseUrl = `/Posts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Posts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postPatchOrCreate(params: {  "data"?: Post; }, options?: any): FetchArgs {
        const baseUrl = `/Posts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Post id
     * @param data An object of model property name/value pairs
     */
    postPrototypePatchAttributes(params: {  "id": string; "data"?: Post; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling postPrototypePatchAttributes");
        }
        const baseUrl = `/Posts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    postReplaceByIdPostPostsidReplace(params: {  "id": string; "data"?: Post; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling postReplaceByIdPostPostsidReplace");
        }
        const baseUrl = `/Posts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    postReplaceByIdPutPostsid(params: {  "id": string; "data"?: Post; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling postReplaceByIdPutPostsid");
        }
        const baseUrl = `/Posts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postReplaceOrCreatePostPostsReplaceOrCreate(params: {  "data"?: Post; }, options?: any): FetchArgs {
        const baseUrl = `/Posts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postReplaceOrCreatePutPosts(params: {  "data"?: Post; }, options?: any): FetchArgs {
        const baseUrl = `/Posts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    postUpdateAll(params: {  "where"?: string; "data"?: Post; }, options?: any): FetchArgs {
        const baseUrl = `/Posts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    postUpsertWithWhere(params: {  "where"?: string; "data"?: Post; }, options?: any): FetchArgs {
        const baseUrl = `/Posts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PostApi - functional programming interface
 */
export const PostApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    postCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = PostApiFetchParamCreator.postCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    postCreate(params: { "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    postCreateChangeStreamGetPostsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PostApiFetchParamCreator.postCreateChangeStreamGetPostsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    postCreateChangeStreamPostPostsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PostApiFetchParamCreator.postCreateChangeStreamPostPostsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    postDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PostApiFetchParamCreator.postDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    postExistsGetPostsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = PostApiFetchParamCreator.postExistsGetPostsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    postExistsHeadPostsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = PostApiFetchParamCreator.postExistsHeadPostsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Post>> {
        const fetchArgs = PostApiFetchParamCreator.postFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postPatchOrCreate(params: { "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Post id
     * @param data An object of model property name/value pairs
     */
    postPrototypePatchAttributes(params: { "id": string; "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    postReplaceByIdPostPostsidReplace(params: { "id": string; "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postReplaceByIdPostPostsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    postReplaceByIdPutPostsid(params: { "id": string; "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postReplaceByIdPutPostsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postReplaceOrCreatePostPostsReplaceOrCreate(params: { "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postReplaceOrCreatePostPostsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postReplaceOrCreatePutPosts(params: { "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postReplaceOrCreatePutPosts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    postUpdateAll(params: { "where"?: string; "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = PostApiFetchParamCreator.postUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    postUpsertWithWhere(params: { "where"?: string; "data"?: Post;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Post> {
        const fetchArgs = PostApiFetchParamCreator.postUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PostApi - object-oriented interface
 */
export class PostApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    postCount(params: {  "where"?: string; }, options?: any) {
        return PostApiFp.postCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    postCreate(params: {  "data"?: Post; }, options?: any) {
        return PostApiFp.postCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    postCreateChangeStreamGetPostsChangeStream(params: {  "options"?: string; }, options?: any) {
        return PostApiFp.postCreateChangeStreamGetPostsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    postCreateChangeStreamPostPostsChangeStream(params: {  "options"?: string; }, options?: any) {
        return PostApiFp.postCreateChangeStreamPostPostsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    postDeleteById(params: {  "id": string; }, options?: any) {
        return PostApiFp.postDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    postExistsGetPostsidExists(params: {  "id": string; }, options?: any) {
        return PostApiFp.postExistsGetPostsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    postExistsHeadPostsid(params: {  "id": string; }, options?: any) {
        return PostApiFp.postExistsHeadPostsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFind(params: {  "filter"?: string; }, options?: any) {
        return PostApiFp.postFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return PostApiFp.postFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    postFindOne(params: {  "filter"?: string; }, options?: any) {
        return PostApiFp.postFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postPatchOrCreate(params: {  "data"?: Post; }, options?: any) {
        return PostApiFp.postPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Post id
     * @param data An object of model property name/value pairs
     */
    postPrototypePatchAttributes(params: {  "id": string; "data"?: Post; }, options?: any) {
        return PostApiFp.postPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    postReplaceByIdPostPostsidReplace(params: {  "id": string; "data"?: Post; }, options?: any) {
        return PostApiFp.postReplaceByIdPostPostsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    postReplaceByIdPutPostsid(params: {  "id": string; "data"?: Post; }, options?: any) {
        return PostApiFp.postReplaceByIdPutPostsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postReplaceOrCreatePostPostsReplaceOrCreate(params: {  "data"?: Post; }, options?: any) {
        return PostApiFp.postReplaceOrCreatePostPostsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    postReplaceOrCreatePutPosts(params: {  "data"?: Post; }, options?: any) {
        return PostApiFp.postReplaceOrCreatePutPosts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    postUpdateAll(params: {  "where"?: string; "data"?: Post; }, options?: any) {
        return PostApiFp.postUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    postUpsertWithWhere(params: {  "where"?: string; "data"?: Post; }, options?: any) {
        return PostApiFp.postUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PostApi - factory interface
 */
export const PostApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        postCount(params: {  "where"?: string; }, options?: any) {
            return PostApiFp.postCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        postCreate(params: {  "data"?: Post; }, options?: any) {
            return PostApiFp.postCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        postCreateChangeStreamGetPostsChangeStream(params: {  "options"?: string; }, options?: any) {
            return PostApiFp.postCreateChangeStreamGetPostsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        postCreateChangeStreamPostPostsChangeStream(params: {  "options"?: string; }, options?: any) {
            return PostApiFp.postCreateChangeStreamPostPostsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        postDeleteById(params: {  "id": string; }, options?: any) {
            return PostApiFp.postDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        postExistsGetPostsidExists(params: {  "id": string; }, options?: any) {
            return PostApiFp.postExistsGetPostsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        postExistsHeadPostsid(params: {  "id": string; }, options?: any) {
            return PostApiFp.postExistsHeadPostsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        postFind(params: {  "filter"?: string; }, options?: any) {
            return PostApiFp.postFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        postFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return PostApiFp.postFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        postFindOne(params: {  "filter"?: string; }, options?: any) {
            return PostApiFp.postFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        postPatchOrCreate(params: {  "data"?: Post; }, options?: any) {
            return PostApiFp.postPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Post id
         * @param data An object of model property name/value pairs
         */
        postPrototypePatchAttributes(params: {  "id": string; "data"?: Post; }, options?: any) {
            return PostApiFp.postPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        postReplaceByIdPostPostsidReplace(params: {  "id": string; "data"?: Post; }, options?: any) {
            return PostApiFp.postReplaceByIdPostPostsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        postReplaceByIdPutPostsid(params: {  "id": string; "data"?: Post; }, options?: any) {
            return PostApiFp.postReplaceByIdPutPostsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        postReplaceOrCreatePostPostsReplaceOrCreate(params: {  "data"?: Post; }, options?: any) {
            return PostApiFp.postReplaceOrCreatePostPostsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        postReplaceOrCreatePutPosts(params: {  "data"?: Post; }, options?: any) {
            return PostApiFp.postReplaceOrCreatePutPosts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        postUpdateAll(params: {  "where"?: string; "data"?: Post; }, options?: any) {
            return PostApiFp.postUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        postUpsertWithWhere(params: {  "where"?: string; "data"?: Post; }, options?: any) {
            return PostApiFp.postUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ProductApi - fetch parameter creator
 */
export const ProductApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamGetProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamPostProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productDeleteById");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productExistsGetProductsidExists");
        }
        const baseUrl = `/Products/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productExistsHeadProductsid");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productFindById");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params: {  "id": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypePatchAttributes");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params: {  "id": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productReplaceByIdPostProductsidReplace");
        }
        const baseUrl = `/Products/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params: {  "id": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productReplaceByIdPutProductsid");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params: {  "where"?: string; "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params: {  "where"?: string; "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ProductApi - functional programming interface
 */
export const ProductApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = ProductApiFetchParamCreator.productCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamGetProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productCreateChangeStreamGetProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamPostProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productCreateChangeStreamPostProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ProductApiFetchParamCreator.productExistsGetProductsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ProductApiFetchParamCreator.productExistsHeadProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Product>> {
        const fetchArgs = ProductApiFetchParamCreator.productFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params: { "id": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params: { "id": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceByIdPostProductsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params: { "id": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceByIdPutProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceOrCreatePostProductsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceOrCreatePutProducts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params: { "where"?: string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ProductApiFetchParamCreator.productUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params: { "where"?: string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ProductApi - object-oriented interface
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params: {  "where"?: string; }, options?: any) {
        return ProductApiFp.productCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamGetProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ProductApiFp.productCreateChangeStreamGetProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamPostProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ProductApiFp.productCreateChangeStreamPostProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params: {  "id": string; }, options?: any) {
        return ProductApiFp.productDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params: {  "id": string; }, options?: any) {
        return ProductApiFp.productExistsGetProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params: {  "id": string; }, options?: any) {
        return ProductApiFp.productExistsHeadProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFind(params: {  "filter"?: string; }, options?: any) {
        return ProductApiFp.productFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return ProductApiFp.productFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindOne(params: {  "filter"?: string; }, options?: any) {
        return ProductApiFp.productFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params: {  "id": string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params: {  "id": string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceByIdPostProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params: {  "id": string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceByIdPutProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceOrCreatePostProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceOrCreatePutProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params: {  "where"?: string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params: {  "where"?: string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ProductApi - factory interface
 */
export const ProductApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        productCount(params: {  "where"?: string; }, options?: any) {
            return ProductApiFp.productCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        productCreate(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        productCreateChangeStreamGetProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ProductApiFp.productCreateChangeStreamGetProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        productCreateChangeStreamPostProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ProductApiFp.productCreateChangeStreamPostProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        productDeleteById(params: {  "id": string; }, options?: any) {
            return ProductApiFp.productDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        productExistsGetProductsidExists(params: {  "id": string; }, options?: any) {
            return ProductApiFp.productExistsGetProductsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        productExistsHeadProductsid(params: {  "id": string; }, options?: any) {
            return ProductApiFp.productExistsHeadProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        productFind(params: {  "filter"?: string; }, options?: any) {
            return ProductApiFp.productFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        productFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return ProductApiFp.productFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        productFindOne(params: {  "filter"?: string; }, options?: any) {
            return ProductApiFp.productFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productPatchOrCreate(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Product id
         * @param data An object of model property name/value pairs
         */
        productPrototypePatchAttributes(params: {  "id": string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        productReplaceByIdPostProductsidReplace(params: {  "id": string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceByIdPostProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        productReplaceByIdPutProductsid(params: {  "id": string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceByIdPutProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productReplaceOrCreatePostProductsReplaceOrCreate(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceOrCreatePostProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productReplaceOrCreatePutProducts(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceOrCreatePutProducts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        productUpdateAll(params: {  "where"?: string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        productUpsertWithWhere(params: {  "where"?: string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * PushApi - fetch parameter creator
 */
export const PushApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    pushCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/push/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    pushCreate(params: {  "data"?: Push; }, options?: any): FetchArgs {
        const baseUrl = `/push`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    pushCreateChangeStreamGetPushChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/push/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    pushCreateChangeStreamPostPushChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/push/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    pushDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pushDeleteById");
        }
        const baseUrl = `/push/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    pushExistsGetPushidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pushExistsGetPushidExists");
        }
        const baseUrl = `/push/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    pushExistsHeadPushid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pushExistsHeadPushid");
        }
        const baseUrl = `/push/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/push`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pushFindById");
        }
        const baseUrl = `/push/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/push/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushPatchOrCreate(params: {  "data"?: Push; }, options?: any): FetchArgs {
        const baseUrl = `/push`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Push id
     * @param data An object of model property name/value pairs
     */
    pushPrototypePatchAttributes(params: {  "id": string; "data"?: Push; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pushPrototypePatchAttributes");
        }
        const baseUrl = `/push/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    pushReplaceByIdPostPushidReplace(params: {  "id": string; "data"?: Push; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pushReplaceByIdPostPushidReplace");
        }
        const baseUrl = `/push/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    pushReplaceByIdPutPushid(params: {  "id": string; "data"?: Push; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pushReplaceByIdPutPushid");
        }
        const baseUrl = `/push/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushReplaceOrCreatePostPushReplaceOrCreate(params: {  "data"?: Push; }, options?: any): FetchArgs {
        const baseUrl = `/push/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushReplaceOrCreatePutPush(params: {  "data"?: Push; }, options?: any): FetchArgs {
        const baseUrl = `/push`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    pushUpdateAll(params: {  "where"?: string; "data"?: Push; }, options?: any): FetchArgs {
        const baseUrl = `/push/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    pushUpsertWithWhere(params: {  "where"?: string; "data"?: Push; }, options?: any): FetchArgs {
        const baseUrl = `/push/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PushApi - functional programming interface
 */
export const PushApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    pushCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = PushApiFetchParamCreator.pushCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    pushCreate(params: { "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    pushCreateChangeStreamGetPushChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PushApiFetchParamCreator.pushCreateChangeStreamGetPushChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    pushCreateChangeStreamPostPushChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PushApiFetchParamCreator.pushCreateChangeStreamPostPushChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    pushDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PushApiFetchParamCreator.pushDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    pushExistsGetPushidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = PushApiFetchParamCreator.pushExistsGetPushidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    pushExistsHeadPushid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = PushApiFetchParamCreator.pushExistsHeadPushid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Push>> {
        const fetchArgs = PushApiFetchParamCreator.pushFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushPatchOrCreate(params: { "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Push id
     * @param data An object of model property name/value pairs
     */
    pushPrototypePatchAttributes(params: { "id": string; "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    pushReplaceByIdPostPushidReplace(params: { "id": string; "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushReplaceByIdPostPushidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    pushReplaceByIdPutPushid(params: { "id": string; "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushReplaceByIdPutPushid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushReplaceOrCreatePostPushReplaceOrCreate(params: { "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushReplaceOrCreatePostPushReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushReplaceOrCreatePutPush(params: { "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushReplaceOrCreatePutPush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    pushUpdateAll(params: { "where"?: string; "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = PushApiFetchParamCreator.pushUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    pushUpsertWithWhere(params: { "where"?: string; "data"?: Push;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Push> {
        const fetchArgs = PushApiFetchParamCreator.pushUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PushApi - object-oriented interface
 */
export class PushApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    pushCount(params: {  "where"?: string; }, options?: any) {
        return PushApiFp.pushCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    pushCreate(params: {  "data"?: Push; }, options?: any) {
        return PushApiFp.pushCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    pushCreateChangeStreamGetPushChangeStream(params: {  "options"?: string; }, options?: any) {
        return PushApiFp.pushCreateChangeStreamGetPushChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    pushCreateChangeStreamPostPushChangeStream(params: {  "options"?: string; }, options?: any) {
        return PushApiFp.pushCreateChangeStreamPostPushChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    pushDeleteById(params: {  "id": string; }, options?: any) {
        return PushApiFp.pushDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    pushExistsGetPushidExists(params: {  "id": string; }, options?: any) {
        return PushApiFp.pushExistsGetPushidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    pushExistsHeadPushid(params: {  "id": string; }, options?: any) {
        return PushApiFp.pushExistsHeadPushid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFind(params: {  "filter"?: string; }, options?: any) {
        return PushApiFp.pushFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return PushApiFp.pushFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    pushFindOne(params: {  "filter"?: string; }, options?: any) {
        return PushApiFp.pushFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushPatchOrCreate(params: {  "data"?: Push; }, options?: any) {
        return PushApiFp.pushPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Push id
     * @param data An object of model property name/value pairs
     */
    pushPrototypePatchAttributes(params: {  "id": string; "data"?: Push; }, options?: any) {
        return PushApiFp.pushPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    pushReplaceByIdPostPushidReplace(params: {  "id": string; "data"?: Push; }, options?: any) {
        return PushApiFp.pushReplaceByIdPostPushidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    pushReplaceByIdPutPushid(params: {  "id": string; "data"?: Push; }, options?: any) {
        return PushApiFp.pushReplaceByIdPutPushid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushReplaceOrCreatePostPushReplaceOrCreate(params: {  "data"?: Push; }, options?: any) {
        return PushApiFp.pushReplaceOrCreatePostPushReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    pushReplaceOrCreatePutPush(params: {  "data"?: Push; }, options?: any) {
        return PushApiFp.pushReplaceOrCreatePutPush(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    pushUpdateAll(params: {  "where"?: string; "data"?: Push; }, options?: any) {
        return PushApiFp.pushUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    pushUpsertWithWhere(params: {  "where"?: string; "data"?: Push; }, options?: any) {
        return PushApiFp.pushUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PushApi - factory interface
 */
export const PushApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        pushCount(params: {  "where"?: string; }, options?: any) {
            return PushApiFp.pushCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        pushCreate(params: {  "data"?: Push; }, options?: any) {
            return PushApiFp.pushCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        pushCreateChangeStreamGetPushChangeStream(params: {  "options"?: string; }, options?: any) {
            return PushApiFp.pushCreateChangeStreamGetPushChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        pushCreateChangeStreamPostPushChangeStream(params: {  "options"?: string; }, options?: any) {
            return PushApiFp.pushCreateChangeStreamPostPushChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        pushDeleteById(params: {  "id": string; }, options?: any) {
            return PushApiFp.pushDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        pushExistsGetPushidExists(params: {  "id": string; }, options?: any) {
            return PushApiFp.pushExistsGetPushidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        pushExistsHeadPushid(params: {  "id": string; }, options?: any) {
            return PushApiFp.pushExistsHeadPushid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        pushFind(params: {  "filter"?: string; }, options?: any) {
            return PushApiFp.pushFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        pushFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return PushApiFp.pushFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        pushFindOne(params: {  "filter"?: string; }, options?: any) {
            return PushApiFp.pushFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        pushPatchOrCreate(params: {  "data"?: Push; }, options?: any) {
            return PushApiFp.pushPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Push id
         * @param data An object of model property name/value pairs
         */
        pushPrototypePatchAttributes(params: {  "id": string; "data"?: Push; }, options?: any) {
            return PushApiFp.pushPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        pushReplaceByIdPostPushidReplace(params: {  "id": string; "data"?: Push; }, options?: any) {
            return PushApiFp.pushReplaceByIdPostPushidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        pushReplaceByIdPutPushid(params: {  "id": string; "data"?: Push; }, options?: any) {
            return PushApiFp.pushReplaceByIdPutPushid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        pushReplaceOrCreatePostPushReplaceOrCreate(params: {  "data"?: Push; }, options?: any) {
            return PushApiFp.pushReplaceOrCreatePostPushReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        pushReplaceOrCreatePutPush(params: {  "data"?: Push; }, options?: any) {
            return PushApiFp.pushReplaceOrCreatePutPush(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        pushUpdateAll(params: {  "where"?: string; "data"?: Push; }, options?: any) {
            return PushApiFp.pushUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        pushUpsertWithWhere(params: {  "where"?: string; "data"?: Push; }, options?: any) {
            return PushApiFp.pushUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * RoleApi - fetch parameter creator
 */
export const RoleApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleCreate(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamGetRolesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamPostRolesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleDeleteById");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsGetRolesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleExistsGetRolesidExists");
        }
        const baseUrl = `/Roles/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsHeadRolesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleExistsHeadRolesid");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleFindById");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    rolePatchOrCreate(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts principals of Role.
     * @param id Role id
     * @param where Criteria to match model instances
     */
    rolePrototypeCountPrincipals(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeCountPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in principals of this model.
     * @param id Role id
     * @param data 
     */
    rolePrototypeCreatePrincipals(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeCreatePrincipals");
        }
        const baseUrl = `/Roles/{id}/principals`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all principals of this model.
     * @param id Role id
     */
    rolePrototypeDeletePrincipals(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeDeletePrincipals");
        }
        const baseUrl = `/Roles/{id}/principals`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeDestroyByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeDestroyByIdPrincipals");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling rolePrototypeDestroyByIdPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeFindByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeFindByIdPrincipals");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling rolePrototypeFindByIdPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries principals of Role.
     * @param id Role id
     * @param filter 
     */
    rolePrototypeGetPrincipals(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeGetPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Role id
     * @param data An object of model property name/value pairs
     */
    rolePrototypePatchAttributes(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypePatchAttributes");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     * @param data 
     */
    rolePrototypeUpdateByIdPrincipals(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeUpdateByIdPrincipals");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling rolePrototypeUpdateByIdPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPostRolesidReplace(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleReplaceByIdPostRolesidReplace");
        }
        const baseUrl = `/Roles/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPutRolesid(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleReplaceByIdPutRolesid");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePostRolesReplaceOrCreate(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePutRoles(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpdateAll(params: {  "where"?: string; "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpsertWithWhere(params: {  "where"?: string; "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RoleApi - functional programming interface
 */
export const RoleApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = RoleApiFetchParamCreator.roleCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleCreate(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamGetRolesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.roleCreateChangeStreamGetRolesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamPostRolesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.roleCreateChangeStreamPostRolesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.roleDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsGetRolesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = RoleApiFetchParamCreator.roleExistsGetRolesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsHeadRolesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = RoleApiFetchParamCreator.roleExistsHeadRolesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
        const fetchArgs = RoleApiFetchParamCreator.roleFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    rolePatchOrCreate(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.rolePatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts principals of Role.
     * @param id Role id
     * @param where Criteria to match model instances
     */
    rolePrototypeCountPrincipals(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeCountPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in principals of this model.
     * @param id Role id
     * @param data 
     */
    rolePrototypeCreatePrincipals(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeCreatePrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all principals of this model.
     * @param id Role id
     */
    rolePrototypeDeletePrincipals(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeDeletePrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeDestroyByIdPrincipals(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeDestroyByIdPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeFindByIdPrincipals(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeFindByIdPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries principals of Role.
     * @param id Role id
     * @param filter 
     */
    rolePrototypeGetPrincipals(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoleMapping>> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeGetPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Role id
     * @param data An object of model property name/value pairs
     */
    rolePrototypePatchAttributes(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     * @param data 
     */
    rolePrototypeUpdateByIdPrincipals(params: { "id": string; "fk": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeUpdateByIdPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPostRolesidReplace(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceByIdPostRolesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPutRolesid(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceByIdPutRolesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePostRolesReplaceOrCreate(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceOrCreatePostRolesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePutRoles(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceOrCreatePutRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpdateAll(params: { "where"?: string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = RoleApiFetchParamCreator.roleUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpsertWithWhere(params: { "where"?: string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RoleApi - object-oriented interface
 */
export class RoleApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleCount(params: {  "where"?: string; }, options?: any) {
        return RoleApiFp.roleCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleCreate(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.roleCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamGetRolesChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleApiFp.roleCreateChangeStreamGetRolesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamPostRolesChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleApiFp.roleCreateChangeStreamPostRolesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleDeleteById(params: {  "id": string; }, options?: any) {
        return RoleApiFp.roleDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsGetRolesidExists(params: {  "id": string; }, options?: any) {
        return RoleApiFp.roleExistsGetRolesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsHeadRolesid(params: {  "id": string; }, options?: any) {
        return RoleApiFp.roleExistsHeadRolesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFind(params: {  "filter"?: string; }, options?: any) {
        return RoleApiFp.roleFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return RoleApiFp.roleFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindOne(params: {  "filter"?: string; }, options?: any) {
        return RoleApiFp.roleFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    rolePatchOrCreate(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.rolePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts principals of Role.
     * @param id Role id
     * @param where Criteria to match model instances
     */
    rolePrototypeCountPrincipals(params: {  "id": string; "where"?: string; }, options?: any) {
        return RoleApiFp.rolePrototypeCountPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in principals of this model.
     * @param id Role id
     * @param data 
     */
    rolePrototypeCreatePrincipals(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleApiFp.rolePrototypeCreatePrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all principals of this model.
     * @param id Role id
     */
    rolePrototypeDeletePrincipals(params: {  "id": string; }, options?: any) {
        return RoleApiFp.rolePrototypeDeletePrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeDestroyByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
        return RoleApiFp.rolePrototypeDestroyByIdPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeFindByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
        return RoleApiFp.rolePrototypeFindByIdPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries principals of Role.
     * @param id Role id
     * @param filter 
     */
    rolePrototypeGetPrincipals(params: {  "id": string; "filter"?: string; }, options?: any) {
        return RoleApiFp.rolePrototypeGetPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Role id
     * @param data An object of model property name/value pairs
     */
    rolePrototypePatchAttributes(params: {  "id": string; "data"?: Role; }, options?: any) {
        return RoleApiFp.rolePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     * @param data 
     */
    rolePrototypeUpdateByIdPrincipals(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
        return RoleApiFp.rolePrototypeUpdateByIdPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPostRolesidReplace(params: {  "id": string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceByIdPostRolesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPutRolesid(params: {  "id": string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceByIdPutRolesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePostRolesReplaceOrCreate(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceOrCreatePostRolesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePutRoles(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceOrCreatePutRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpdateAll(params: {  "where"?: string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpsertWithWhere(params: {  "where"?: string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RoleApi - factory interface
 */
export const RoleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        roleCount(params: {  "where"?: string; }, options?: any) {
            return RoleApiFp.roleCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        roleCreate(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.roleCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleCreateChangeStreamGetRolesChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleApiFp.roleCreateChangeStreamGetRolesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleCreateChangeStreamPostRolesChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleApiFp.roleCreateChangeStreamPostRolesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        roleDeleteById(params: {  "id": string; }, options?: any) {
            return RoleApiFp.roleDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleExistsGetRolesidExists(params: {  "id": string; }, options?: any) {
            return RoleApiFp.roleExistsGetRolesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleExistsHeadRolesid(params: {  "id": string; }, options?: any) {
            return RoleApiFp.roleExistsHeadRolesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleFind(params: {  "filter"?: string; }, options?: any) {
            return RoleApiFp.roleFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return RoleApiFp.roleFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleFindOne(params: {  "filter"?: string; }, options?: any) {
            return RoleApiFp.roleFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        rolePatchOrCreate(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.rolePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts principals of Role.
         * @param id Role id
         * @param where Criteria to match model instances
         */
        rolePrototypeCountPrincipals(params: {  "id": string; "where"?: string; }, options?: any) {
            return RoleApiFp.rolePrototypeCountPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in principals of this model.
         * @param id Role id
         * @param data 
         */
        rolePrototypeCreatePrincipals(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleApiFp.rolePrototypeCreatePrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all principals of this model.
         * @param id Role id
         */
        rolePrototypeDeletePrincipals(params: {  "id": string; }, options?: any) {
            return RoleApiFp.rolePrototypeDeletePrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for principals.
         * @param id Role id
         * @param fk Foreign key for principals
         */
        rolePrototypeDestroyByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
            return RoleApiFp.rolePrototypeDestroyByIdPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for principals.
         * @param id Role id
         * @param fk Foreign key for principals
         */
        rolePrototypeFindByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
            return RoleApiFp.rolePrototypeFindByIdPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries principals of Role.
         * @param id Role id
         * @param filter 
         */
        rolePrototypeGetPrincipals(params: {  "id": string; "filter"?: string; }, options?: any) {
            return RoleApiFp.rolePrototypeGetPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Role id
         * @param data An object of model property name/value pairs
         */
        rolePrototypePatchAttributes(params: {  "id": string; "data"?: Role; }, options?: any) {
            return RoleApiFp.rolePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for principals.
         * @param id Role id
         * @param fk Foreign key for principals
         * @param data 
         */
        rolePrototypeUpdateByIdPrincipals(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
            return RoleApiFp.rolePrototypeUpdateByIdPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleReplaceByIdPostRolesidReplace(params: {  "id": string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceByIdPostRolesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleReplaceByIdPutRolesid(params: {  "id": string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceByIdPutRolesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleReplaceOrCreatePostRolesReplaceOrCreate(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceOrCreatePostRolesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleReplaceOrCreatePutRoles(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceOrCreatePutRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleUpdateAll(params: {  "where"?: string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleUpsertWithWhere(params: {  "where"?: string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * RoleMappingApi - fetch parameter creator
 */
export const RoleMappingApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleMappingCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleMappingCreate(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleMappingDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingDeleteById");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsGetRoleMappingsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingExistsGetRoleMappingsidExists");
        }
        const baseUrl = `/RoleMappings/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsHeadRoleMappingsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingExistsHeadRoleMappingsid");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingFindById");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingPatchOrCreate(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation role.
     * @param id RoleMapping id
     * @param refresh 
     */
    roleMappingPrototypeGetRole(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingPrototypeGetRole");
        }
        const baseUrl = `/RoleMappings/{id}/role`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id RoleMapping id
     * @param data An object of model property name/value pairs
     */
    roleMappingPrototypePatchAttributes(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingPrototypePatchAttributes");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPostRoleMappingsidReplace(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingReplaceByIdPostRoleMappingsidReplace");
        }
        const baseUrl = `/RoleMappings/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPutRoleMappingsid(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingReplaceByIdPutRoleMappingsid");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePutRoleMappings(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpdateAll(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpsertWithWhere(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RoleMappingApi - functional programming interface
 */
export const RoleMappingApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleMappingCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleMappingCreate(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleMappingDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsGetRoleMappingsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingExistsGetRoleMappingsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsHeadRoleMappingsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingExistsHeadRoleMappingsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoleMapping>> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingPatchOrCreate(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation role.
     * @param id RoleMapping id
     * @param refresh 
     */
    roleMappingPrototypeGetRole(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingPrototypeGetRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id RoleMapping id
     * @param data An object of model property name/value pairs
     */
    roleMappingPrototypePatchAttributes(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPostRoleMappingsidReplace(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceByIdPostRoleMappingsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPutRoleMappingsid(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceByIdPutRoleMappingsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePutRoleMappings(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceOrCreatePutRoleMappings(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpdateAll(params: { "where"?: string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpsertWithWhere(params: { "where"?: string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RoleMappingApi - object-oriented interface
 */
export class RoleMappingApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleMappingCount(params: {  "where"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleMappingCreate(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleMappingDeleteById(params: {  "id": string; }, options?: any) {
        return RoleMappingApiFp.roleMappingDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsGetRoleMappingsidExists(params: {  "id": string; }, options?: any) {
        return RoleMappingApiFp.roleMappingExistsGetRoleMappingsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsHeadRoleMappingsid(params: {  "id": string; }, options?: any) {
        return RoleMappingApiFp.roleMappingExistsHeadRoleMappingsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFind(params: {  "filter"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindOne(params: {  "filter"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingPatchOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation role.
     * @param id RoleMapping id
     * @param refresh 
     */
    roleMappingPrototypeGetRole(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return RoleMappingApiFp.roleMappingPrototypeGetRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id RoleMapping id
     * @param data An object of model property name/value pairs
     */
    roleMappingPrototypePatchAttributes(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPostRoleMappingsidReplace(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceByIdPostRoleMappingsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPutRoleMappingsid(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceByIdPutRoleMappingsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePutRoleMappings(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceOrCreatePutRoleMappings(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpdateAll(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpsertWithWhere(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RoleMappingApi - factory interface
 */
export const RoleMappingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        roleMappingCount(params: {  "where"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        roleMappingCreate(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        roleMappingDeleteById(params: {  "id": string; }, options?: any) {
            return RoleMappingApiFp.roleMappingDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleMappingExistsGetRoleMappingsidExists(params: {  "id": string; }, options?: any) {
            return RoleMappingApiFp.roleMappingExistsGetRoleMappingsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleMappingExistsHeadRoleMappingsid(params: {  "id": string; }, options?: any) {
            return RoleMappingApiFp.roleMappingExistsHeadRoleMappingsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleMappingFind(params: {  "filter"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleMappingFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleMappingFindOne(params: {  "filter"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleMappingPatchOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation role.
         * @param id RoleMapping id
         * @param refresh 
         */
        roleMappingPrototypeGetRole(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return RoleMappingApiFp.roleMappingPrototypeGetRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id RoleMapping id
         * @param data An object of model property name/value pairs
         */
        roleMappingPrototypePatchAttributes(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleMappingReplaceByIdPostRoleMappingsidReplace(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceByIdPostRoleMappingsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleMappingReplaceByIdPutRoleMappingsid(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceByIdPutRoleMappingsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleMappingReplaceOrCreatePutRoleMappings(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceOrCreatePutRoleMappings(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleMappingUpdateAll(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleMappingUpsertWithWhere(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * SubmissionsApi - fetch parameter creator
 */
export const SubmissionsApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    submissionsCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    submissionsCreate(params: {  "data"?: Submissions; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    submissionsCreateChangeStreamGetSubmissionsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    submissionsCreateChangeStreamPostSubmissionsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    submissionsDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling submissionsDeleteById");
        }
        const baseUrl = `/Submissions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    submissionsExistsGetSubmissionsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling submissionsExistsGetSubmissionsidExists");
        }
        const baseUrl = `/Submissions/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    submissionsExistsHeadSubmissionsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling submissionsExistsHeadSubmissionsid");
        }
        const baseUrl = `/Submissions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling submissionsFindById");
        }
        const baseUrl = `/Submissions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsPatchOrCreate(params: {  "data"?: Submissions; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Submissions id
     * @param data An object of model property name/value pairs
     */
    submissionsPrototypePatchAttributes(params: {  "id": string; "data"?: Submissions; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling submissionsPrototypePatchAttributes");
        }
        const baseUrl = `/Submissions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    submissionsReplaceByIdPostSubmissionsidReplace(params: {  "id": string; "data"?: Submissions; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling submissionsReplaceByIdPostSubmissionsidReplace");
        }
        const baseUrl = `/Submissions/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    submissionsReplaceByIdPutSubmissionsid(params: {  "id": string; "data"?: Submissions; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling submissionsReplaceByIdPutSubmissionsid");
        }
        const baseUrl = `/Submissions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsReplaceOrCreatePostSubmissionsReplaceOrCreate(params: {  "data"?: Submissions; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsReplaceOrCreatePutSubmissions(params: {  "data"?: Submissions; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    submissionsUpdateAll(params: {  "where"?: string; "data"?: Submissions; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    submissionsUpsertWithWhere(params: {  "where"?: string; "data"?: Submissions; }, options?: any): FetchArgs {
        const baseUrl = `/Submissions/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SubmissionsApi - functional programming interface
 */
export const SubmissionsApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    submissionsCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    submissionsCreate(params: { "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    submissionsCreateChangeStreamGetSubmissionsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsCreateChangeStreamGetSubmissionsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    submissionsCreateChangeStreamPostSubmissionsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsCreateChangeStreamPostSubmissionsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    submissionsDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    submissionsExistsGetSubmissionsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsExistsGetSubmissionsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    submissionsExistsHeadSubmissionsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsExistsHeadSubmissionsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Submissions>> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsPatchOrCreate(params: { "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Submissions id
     * @param data An object of model property name/value pairs
     */
    submissionsPrototypePatchAttributes(params: { "id": string; "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    submissionsReplaceByIdPostSubmissionsidReplace(params: { "id": string; "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsReplaceByIdPostSubmissionsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    submissionsReplaceByIdPutSubmissionsid(params: { "id": string; "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsReplaceByIdPutSubmissionsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsReplaceOrCreatePostSubmissionsReplaceOrCreate(params: { "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsReplaceOrCreatePostSubmissionsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsReplaceOrCreatePutSubmissions(params: { "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsReplaceOrCreatePutSubmissions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    submissionsUpdateAll(params: { "where"?: string; "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    submissionsUpsertWithWhere(params: { "where"?: string; "data"?: Submissions;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
        const fetchArgs = SubmissionsApiFetchParamCreator.submissionsUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SubmissionsApi - object-oriented interface
 */
export class SubmissionsApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    submissionsCount(params: {  "where"?: string; }, options?: any) {
        return SubmissionsApiFp.submissionsCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    submissionsCreate(params: {  "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    submissionsCreateChangeStreamGetSubmissionsChangeStream(params: {  "options"?: string; }, options?: any) {
        return SubmissionsApiFp.submissionsCreateChangeStreamGetSubmissionsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    submissionsCreateChangeStreamPostSubmissionsChangeStream(params: {  "options"?: string; }, options?: any) {
        return SubmissionsApiFp.submissionsCreateChangeStreamPostSubmissionsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    submissionsDeleteById(params: {  "id": string; }, options?: any) {
        return SubmissionsApiFp.submissionsDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    submissionsExistsGetSubmissionsidExists(params: {  "id": string; }, options?: any) {
        return SubmissionsApiFp.submissionsExistsGetSubmissionsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    submissionsExistsHeadSubmissionsid(params: {  "id": string; }, options?: any) {
        return SubmissionsApiFp.submissionsExistsHeadSubmissionsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFind(params: {  "filter"?: string; }, options?: any) {
        return SubmissionsApiFp.submissionsFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return SubmissionsApiFp.submissionsFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    submissionsFindOne(params: {  "filter"?: string; }, options?: any) {
        return SubmissionsApiFp.submissionsFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsPatchOrCreate(params: {  "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Submissions id
     * @param data An object of model property name/value pairs
     */
    submissionsPrototypePatchAttributes(params: {  "id": string; "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    submissionsReplaceByIdPostSubmissionsidReplace(params: {  "id": string; "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsReplaceByIdPostSubmissionsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    submissionsReplaceByIdPutSubmissionsid(params: {  "id": string; "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsReplaceByIdPutSubmissionsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsReplaceOrCreatePostSubmissionsReplaceOrCreate(params: {  "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsReplaceOrCreatePostSubmissionsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    submissionsReplaceOrCreatePutSubmissions(params: {  "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsReplaceOrCreatePutSubmissions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    submissionsUpdateAll(params: {  "where"?: string; "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    submissionsUpsertWithWhere(params: {  "where"?: string; "data"?: Submissions; }, options?: any) {
        return SubmissionsApiFp.submissionsUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SubmissionsApi - factory interface
 */
export const SubmissionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        submissionsCount(params: {  "where"?: string; }, options?: any) {
            return SubmissionsApiFp.submissionsCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        submissionsCreate(params: {  "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        submissionsCreateChangeStreamGetSubmissionsChangeStream(params: {  "options"?: string; }, options?: any) {
            return SubmissionsApiFp.submissionsCreateChangeStreamGetSubmissionsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        submissionsCreateChangeStreamPostSubmissionsChangeStream(params: {  "options"?: string; }, options?: any) {
            return SubmissionsApiFp.submissionsCreateChangeStreamPostSubmissionsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        submissionsDeleteById(params: {  "id": string; }, options?: any) {
            return SubmissionsApiFp.submissionsDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        submissionsExistsGetSubmissionsidExists(params: {  "id": string; }, options?: any) {
            return SubmissionsApiFp.submissionsExistsGetSubmissionsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        submissionsExistsHeadSubmissionsid(params: {  "id": string; }, options?: any) {
            return SubmissionsApiFp.submissionsExistsHeadSubmissionsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        submissionsFind(params: {  "filter"?: string; }, options?: any) {
            return SubmissionsApiFp.submissionsFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        submissionsFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return SubmissionsApiFp.submissionsFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        submissionsFindOne(params: {  "filter"?: string; }, options?: any) {
            return SubmissionsApiFp.submissionsFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        submissionsPatchOrCreate(params: {  "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Submissions id
         * @param data An object of model property name/value pairs
         */
        submissionsPrototypePatchAttributes(params: {  "id": string; "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        submissionsReplaceByIdPostSubmissionsidReplace(params: {  "id": string; "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsReplaceByIdPostSubmissionsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        submissionsReplaceByIdPutSubmissionsid(params: {  "id": string; "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsReplaceByIdPutSubmissionsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        submissionsReplaceOrCreatePostSubmissionsReplaceOrCreate(params: {  "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsReplaceOrCreatePostSubmissionsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        submissionsReplaceOrCreatePutSubmissions(params: {  "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsReplaceOrCreatePutSubmissions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        submissionsUpdateAll(params: {  "where"?: string; "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        submissionsUpsertWithWhere(params: {  "where"?: string; "data"?: Submissions; }, options?: any) {
            return SubmissionsApiFp.submissionsUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};

